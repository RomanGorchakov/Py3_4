Горчаков Роман Владимирович. Вариант 2
# Лабораторная работа 4.3. Наследование и полиморфизм в языке Python

В организации наследования участвуют как минимум два класса: класс-родитель и класс-потомок. При этом возможно множественное наследование, в этом случае у класса потомка может быть несколько родителей. Не все языки программирования поддерживают множественное наследование, но в Python можно его использовать. По умолчанию все классы в Python являются наследниками от object, явно этот факт указывать не нужно.

Полиморфизм, как правило, используется с позиции переопределения методов базового класса в классе-наследнике. Проще всего это рассмотреть на примере. Добавим в базовый класс метод info(), который печатает сводную информацию по объекту класса Figure и переопределим этот метод в классе Rectangle, добавим в него дополнительные данные:

> class Figure:

>> def __init__(self, color):
>>> self.__color = color

>> @property
>> 
>> def color(self):
>>> return self.__color

>> @color.setter
>> 
>> def color(self, c):
>>> self.__color = c

>> def info(self):
>>> print("Figure")
>>> 
>>> print("Color: " + self.__color)


> class Rectangle(Figure):

>> def __init__(self, width, height, color):
>>> super().__init__(color)
>>> 
>>> self.__width = width
>>> 
>>> self.__height = height

>> @property
>> 
>> def width(self):
>>> return self.__width

>> @width.setter
>> 
>> def width(self, w):
>>> if w > 0:
>>>> self.__width = w
>>>>
>>> else:
>>>> raise ValueError

>> @property
>> 
>> def height(self):
>>> return self.__height

>> @height.setter
>> 
>> def height(self, h):
>>> if h > 0:
>>>> self.__height = h
>>>> 
>>> else:
>>>> raise ValueError

>> def area(self):
>>> return self.__width * self.__height

>> def info(self):
>>> print("Rectangle")
>>> 
>>> print("Color: " + self.color)
>>> 
>>> print("Width: " + str(self.width))
>>> 
>>> print("Height: " + str(self.height))
>>> 
>>> print("Area: " + str(self.area()))

Наследственная связь между классами устанавливается через подкласс. При определении дочернего после его имени в скобках указывается родительский. Определив в дочернем классе метод, одноименный методу родительского, мы тем самым переопределяем метод родительского класса.

Часто требуется не столько заменить, то есть полностью переопределить, метод родительского класса в дочернем, сколько дополнить, то есть расширить, код метода родительского класса в дочернем. В таких случаях решением является вызов метода надкласса в теле соответствующего метода подкласса. Обычно после этого в теле метода подкласса пишется дополнительный код.

Когда создается объект от дочернего класса, сначала вызывается его конструктор, если он есть. Интерпретатор еще не знает, что в теле этого конструктора будет вызван конструктор родительского класса. Ведь это не обязательно. Значит, если все параметры дочернего конструктора не имеют значений по умолчанию, при построении объекта все значения должны передаваться. Поэтому, если требуется допустить создание объектов от дочернего класса без передачи аргументов, придется назначить значения по умолчанию также в конструкторе дочернего класса.

Абстрактный класс можно рассматривать как образец для других классов. Он позволяет вам создать набор методов, которые должны быть созданы в любых дочерних классах, построенных на основе абстрактного класса. Класс, содержащий один или несколько абстрактных методов, называется абстрактным классом. Абстрактный метод - это метод, который имеет объявление, но не имеет реализации. При проектировании больших функциональных единиц мы используем абстрактный класс. Когда мы хотим предоставить общий интерфейс для различных реализаций компонента, мы используем абстрактный класс.

Определив абстрактный базовый класс, вы можете определить общий прикладной программный интерфейс (API) для набора подклассов. Эта возможность особенно полезна в ситуациях, когда сторонняя организация собирается предоставить реализации, например, с плагинами, но также может помочь вам при работе в большой команде или с большой базой кода, где сложно держать все классы в уме. или невозможно.

По умолчанию Python не предоставляет абстрактных классов. Python поставляется с модулем, который обеспечивает основу для определения абстрактных базовых классов (ABC), и имя этого модуля - ABC. ABC работает, декорируя методы базового класса как абстрактные, а затем регистрируя конкретные классы как реализации абстрактной базы. Метод становится абстрактным, если он украшен ключевым словом @abstractmethod.

Создавая подклассы непосредственно из базы, мы можем избежать необходимости явно регистрировать класс. В этом случае управление классом Python используется для распознавания PluginImplementation как реализации абстрактной PluginBase. Побочным эффектом использования прямого подкласса является то, что можно найти все реализации вашего плагина, запросив у базового класса список известных классов, производных от него.

Конкретные классы содержат только конкретные (обычные) методы, тогда как абстрактные классы могут содержать как конкретные методы, так и абстрактные методы. Конкретный класс обеспечивает реализацию абстрактных методов, абстрактный базовый класс также может предоставлять реализацию, вызывая методы через super().

Абстрактные классы включают в себя атрибуты в дополнение к методам, вы можете потребовать атрибуты в конкретных классах, определив их с помощью @abstractproperty. Абстрактные классы неполны, потому что у них есть методы, у которых нет никого. Если Python позволяет создавать объект для абстрактных классов, то использовать этот объект, если ктолибо вызывает абстрактный метод, но фактической реализации для вызова нет.
